- **JPA 영속성 컨텍스트의 이점 (5가지)**
    
    **영속성 컨텍스트**는 엔티티를 1차 캐시에 저장하고 관리하는 JPA의 핵심 개념으로, 다음과 같은 이점을 제공한다.
    
    1. **1차 캐시**
        - DB 조회 없이 **메모리에서 엔티티 조회** 가능 → 성능 향상
    2. **변경 감지(Dirty Checking)**
        - 엔티티 변경 시 자동으로 **UPDATE 쿼리 반영** → 코드 단순화
    3. **트랜잭션을 활용한 원자적 연산**
        - 트랜잭션 종료 시 **한 번의 Flush로 일괄 처리** → 일관성 유지
    4. **지연 로딩(Lazy Loading) 지원**
        - 연관 엔티티를 **필요할 때만 로딩** → 성능 최적화
    5. **엔티티 동일성 보장**
        - 같은 트랜잭션 내에서 동일 엔티티는 **항상 같은 인스턴스 유지**
- **JPA Propagation 전파 단계 (REQUIRED vs REQUIRES_NEW)**
    - 트랜잭션 전파(Propagation)는 기존 트랜잭션이 있을 때 **새로운 트랜잭션을 어떻게 처리할지** 결정하는 옵션이다.
    1. **REQUIRED (기본값)**
        - 기존 트랜잭션이 있으면 **그 트랜잭션을 사용**
        - 없으면 **새로운 트랜잭션을 생성**
        - 여러 메서드가 같은 트랜잭션을 공유 → 하나라도 실패하면 전체 롤백
    2. **REQUIRES_NEW**
        - **항상 새로운 트랜잭션을 생성**
        - 기존 트랜잭션이 있더라도 **일시 정지하고 새로운 트랜잭션을 실행**
        - 각각 독립적인 트랜잭션이므로 한 쪽이 롤백되어도 다른 쪽에는 영향 없음
        - 보통 반드시 성공해야 하는 기능에 사용
- **JPA를 사용하는 이유**
    
    JPA를 사용하는 이유는 개발자의 코딩 패러다임과 데이터베이스 접근 방식을 일치시키기 위해서입니다. 기본적인 SQL은 테이블과 행, 즉 Map 형태로 데이터를 다루지만, 자바는 객체지향 언어라 객체 중심으로 개발을 합니다.
    
    JPA 같은 ORM은 이런 차이를 객체 중심으로 변환해 줘서 개발자가 객체를 다루듯이 데이터를 편하게 조작할 수 있게 도와줍니다. 또한, JPA는 영속성 컨텍스트를 통해 데이터의 상태를 관리하고 캐싱, 변경 감지 등 효율적인 기능도 제공해 성능과 개발 생산성을 높여줍니다.
    
- **N + 1 문제와 해결 방법**
    
    **📌 N + 1 문제란?**
    
    - **하나의 쿼리 실행(N)** 후, 관련된 N개의 데이터를 조회할 때 **추가적인 쿼리(N번)** 가 실행되는 문제
    - 즉, **총 N + 1번의 쿼리 발생**
    
    **🔍 발생 원인**
    
    - JPA에서 **지연 로딩(Lazy Loading)** 을 사용할 때, **연관된 엔티티를 개별적으로 조회**하기 때문
    - 즉시 로딩 중에도 서브 쿼리로 잘못된 조회를 할 시가에 발생 가능
    - 예: `부모 엔티티` 조회 후, 각 `자식 엔티티`를 별도 쿼리로 가져오는 경우
    
    ```
    List<Parent> parents = parentRepository.findAll(); // 1번 실행
    for (Parent parent : parents) {
        System.out.println(parent.getChildren()); // N번 실행 (각 부모마다 자식 조회)
    }
    ```
    
    **✅ 해결 방법**
    
    1. **즉시 로딩(EAGER LOADING) 사용**
        - `@OneToMany(fetch = FetchType.EAGER)`
        - 하지만 **불필요한 데이터 로딩 가능성** 있음
    2. **Fetch Join 사용 (권장)**
        - `JOIN FETCH`를 이용해 한 번의 쿼리로 **연관된 엔티티까지 조회**
        - 예: `@Query("SELECT p FROM Parent p JOIN FETCH p.children")`
