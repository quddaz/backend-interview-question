
- 시스템 콜이 무엇인가요?
    
    시스템 콜은 **운영체제(OS)가 제공하는 민감한 서비스를 사용하기 위한 프로그래밍 인터페이스**입니다. 마치 건물의 중요한 구역에 접근하기 위한 **안전문**과 같습니다. 사용자 프로그램이 직접 접근할 수 없는, 운영체제만이 통제하는 영역의 기능들을 시스템 콜을 통해 요청하는 거죠.
    
    시스템 콜이 등장하게 된 주된 이유는 **보안과 자원 보호** 때문입니다. 운영체제를 설계하는 개발자들은 깊은 고민에 빠졌습니다. '만약 사용자 프로그램이 운영체제의 제어 없이 하드웨어에 직접 접근하거나 중요한 시스템 설정을 마음대로 바꾼다면 어떻게 될까?' 이 염려가 현실이 된다면 보안이 취약해지고 자원 오용이 일어나게 됩니다. 이러한 문제를 막기 위해 운영체제는 사용자 모드와 커널 모드라는 두가지 실행 모드를 만들었습니다. 
    
- 시분할 기법은 왜 쓰는 건가요?
    
    시분할 기법은 CPU의 가상화를 위해 사용하게 되었습니다. 여기서 CPU 가상화란 하나의 CPU로 프로세스들을 여러개 실행하도록 보이는 것을 말합니다. 이 기법을 통해 CPU는 여러개의 프로세스들이 실행되는 것처럼 보이며 더 효율적으로 작업을 할 수 있습니다. 
    
- 인터럽트에 대해 설명해주세요
    
    인터럽트는 **CPU가 프로그램을 실행하고 있을 때, 입출력(I/O) 장치나 예외 상황 등 예상치 못한 사건이 발생하여 CPU에게 알려 특정 작업을 처리하도록 하는 메커니즘**입니다. 운영체제는 시분할 기법을 통해 CPU 가상화를 구현하려 했습니다. 그러나 여기서 문제가 발생합니다. 하나의 CPU에서는 1개의 프로세스만 실행 가능하기에 다른 프로세스가 CPU를 넘겨 받을 방법이 없었습니다. 또한 CPU가 무한 루프에 빠지거나 대기 작업에 대해 좋은 성능을 발휘하지 못해 인터럽트가 등장했습니다. 결론적으로 CPU는 외부 또는 내부에서 발생하는 사건을 감지하고 적절히 수행할 수 있는 일종의 트리거입니다.
    
- 컨텍스트 스위칭은 무엇인가요?
    
    컨텍스트 스위칭은 CPU가 현재 실행 중인 하나의 프로세스의 실행 상태를  PCB에 저장하고 다른 프로세스의 실행 상태를 불러와 CPU 제어권을 넘겨주는 과정을 말합니다. 
    
    여기서 실행 상태란 CPU 레지스터 값, 스텍 포인터, 프로그램 카운터 등이 있습니다. 
    
    이러한 작업은 멀티태스킹 구현을 위한 과정입니다.
    
- 프로세스와 스레드의 차이점을 설명해주세요
    
    프로세스는 실행 중인 프로그램을 의미합니다. 운영체제로부터 독립적인 실행 환경을 할당받습니다. 즉 자신만의 독자적인 메모리 영역을 가집니다.
    
    스레드는 프로세스 내에서 실행되는 작은 단위의 작업입니다. 하나의 프로세스는 하나 이상의 스레드를 가지며 스택과 레지스터를 제외한 메모리 공간(코드/데이터/힙)을 공유합니다. 
    
- 뮤텍스와 세마포어의 차이점은 무엇인가요?
    
    뮤텍스는 한 임계 구역 내에 하나의 작업만 보장하는 기법이며
    
    세마포어는 하나의 자원을 여러 명이 공유할 수 있게하는 기법입니다. 
    
- CPU 스케줄링에 대해 설명해주세요
    
    CPU 스케줄링은 운영체제가 컴퓨터의 뇌라고 할 수 있는 CPU 자원을 어떤 프로세스에게 할당할지 결정하고 관리하는 과정입니다. 여러 프로세스가 한정된 CPU를 효율적으로 나눠 쓰고, 사용자에게는 여러 작업이 동시에 돌아가는 것처럼 보이게 하는 역할이라고 보시면 됩니다.
    
    - 평가 방법은요?
        
        스케줄링 기법들을 평가할 때는 크게 세 가지를 봅니다. 첫째는 '응답 시간'인데요, 제가 어떤 작업을 시켰을 때 얼마나 빨리 반응이 오는가 하는 사용자 체감 응답성입니다. 둘째는 '반환 시간'으로, 작업이 시작돼서 완전히 끝날 때까지 걸리는 전체 시간입니다. 마지막으로 '공정성'인데요, 모든 프로세스가 CPU를 공평하게 나눠 쓰는지 보는 겁니다.
        
    - CPU 스케줄링 알고리즘의 방식
        
        먼저, '비선점 방식'은 한 번 CPU를 잡은 프로세스가 스스로 CPU를 놓아주거나 작업이 끝날 때까지 다른 프로세스가 CPU를 빼앗을 수 없는 방식입니다. 이어서 '선점 방식'은 지금 CPU를 쓰고 있는 프로세스라도 운영체제가 강제로 CPU를 빼앗아서 다른 프로세스에게 넘겨줄 수 있는 방식입니다. 주로 타이머 인터럽트 같은 걸 활용하죠.
        
- 교착상태와 기아상태의 해결방법에 대해 설명해보세요
    
    교착 상태란 두 개 이상의 프로세스가 서로 상대방이 가진 자원을 기다리면서 영원히 블록되는 현상을 의미합니다. 교착 상태는 4가지의 필수 조건이 있어야 발생합니다. 상호 배체, 점유와 대기, 비선점, 순환 대기, 즉 이 4개 중에 1개라도 조건이 없다면 일어나지 않는다는 의미이기도 합니다.  그렇기에 교착 상태의 조건 중 1개라도 부정하거나 교착 상태를 회피하는 알고리즘을 사용합니다.
    
    기아 상태는 특정 프로세스가 자원을 계속 요청해도 스케줄링 정책에 의해 자원할당을 받지 못하는 현상을 의미합니다. 주요 원인은 우선순위 기반 스케줄링이며 공정성을 해친 것입니다. 이러한 기아 상태를 해결하는 방법은 공정성이 높은 라운드 로빈 스케줄링을 활용하거나 멀티 피드백 큐 같은 우선순위 큐를 사용하는 방식을 사용합니다.
    
- 멀티프로세서의 캐시에 대해 말해주세요
    
    멀티프로세서 시스템에서 각 CPU는 독립적으로 자신만의 로컬 캐시(Local Cache)를 가집니다. 이는 각 CPU가 더 빠르게 데이터에 접근하여 전체적인 성능을 높이기 위함입니다 
    
    멀티프로세스 캐시에서 중요한 과제는 캐시 동기화입니다. 각 CPU는 자신만의 로컬 캐시를 메모리에서 복사해오지만 만약 메모리가 갱신된다면 캐시와 메모리 사이의 정합성을 해치게 됩니다. 이러한 문제를 해결하고 데이터 일관성을 유지하는 것을 캐시 동기화라고 합니다. 
    
    또한 캐시 효율성을 높이기 위해 캐시 지역성을 활용합니다. 
    
    캐시는 이 특성을 활용하여 CPU가 다음에 필요로 할 데이터를 예측하고 미리 가져다 놓음으로써 히트율을 높이고 성능을 개선합니다
    
- 가상 메모리에 대해 말해주세요
    
    **가상 메모리**는 **실제 물리 메모리(RAM)의 크기에 관계없이, 각 프로세스가 자신만의 거대하고 연속적인 메모리 공간을 가지고 있다고 착각하게 만드는 운영체제의 메모리 관리 기법**입니다. 즉, 실제 메모리보다 더 큰 메모리를 사용하는 것처럼 보이게 하는 기술입니다.
