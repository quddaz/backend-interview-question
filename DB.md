
- **데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요**
    
    인덱스는 **검색 성능을 향상**시키기 위해 사용됩니다. 데이터의 특정 컬럼에 인덱스를 생성하면 검색 속도가 빨라지며, 특히 대량의 데이터를 다룰 때 **조회 성능을 크게 개선**할 수 있습니다.
    
    하지만 인덱스에는 몇 가지 단점도 있습니다.
    
    1. **쓰기 성능 저하**: 데이터를 `INSERT`, `UPDATE`, `DELETE`할 때마다 인덱스도 함께 갱신해야 하므로 쓰기 성능이 저하될 수 있습니다.
    2. **추가적인 저장 공간 필요**: 인덱스를 유지하기 위해 추가적인 저장 공간이 필요합니다.
    3. **잘못된 인덱스 사용 시 오히려 성능 저하**: 인덱스를 너무 많이 만들거나, 적절하지 않은 컬럼에 생성하면 쿼리 최적화가 오히려 어려워질 수 있습니다.
    
    따라서 인덱스는 **조회 성능을 높이는 강력한 도구지만, 신중하게 설계해야 한다**는 점을 염두에 두어야 합니다.
    
    - 꼬리 질문
        - 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
            - 인덱스는 검색 성능을 향상시키지만, 삽입, 삭제, 수정 작업 시 오버헤드가 발생합니다. 그 이유는 인덱스를 갱신하기 때문입니다. 예를 들어 B-Tree 인덱스의 경우 균형 유지를 위한 노드 재조정 작업이 필요합니다 .
        - 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
            - MySQL의 경우 기본키를 기반으로 자동으로 클러스터드 인덱스를 생성합니다. 즉 인덱스를 사용하지 않아도 내부적으로는 인덱스 사용이 가능합니다.
            - 또한 실제 실행 계획 분석을 통해 한번 점검을 해보아야만 합니다.
        - ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재 여부와 연관지어서 설명해 주세요.
            - ORDER BY의 경우 정렬된 상태를 그대로 가져오면 되기에 빠르게 동작하며 인덱스가 없는 경우 임시 테이블을 생성하기 때문에 성능이 저하됩니다.
            - GROUP BY의 경우에도 인덱스가 있는 경우 순서대로 읽으며 중복 그룹을 찾아 속도가 빨라지며 없는 경우 임시 테이블을 생성하기에 성능 저하가 발생합니다.
        - 인덱스가 데이터의 물리적 저장에도 영향을 미치나요?
            - 클러스터형 인덱스는 물리적 저장 순서에 영향을 끼치며 아닌 경우는 그렇지 않습니다.
        - (A, B)로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청하면 인덱스를 탈까요?
            - 아닙니다. 인덱스는 기본적으로 왼쪽의 법칙을 유지하며 왼쪽 조건을 기반으로 동작합니다. 그렇기에 Like 문에서 뒷쪽을 지정하거나 복합 인덱스에서 뒷쪽문을 기준으로 검색 시 인덱스 사용이 불가능합니다.
        - 세컨더리 인덱스는 어떻게 동작하나요?
            - 세컨더리 인덱스는 조회 시 PK 값을 저장하여 최종 데이터 조회 때 클러스터링 인덱스를 참조합니다.
- **트랜잭션에 대해서 설명해주세요.**
    
    트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 단위입니다. 트랜잭션은 ACID 성질에 따라 동작합니다.
    
    - Atomicity(원자성) : 트랜잭션의 연산은 완벽히 수행되어야 하며, 하나라도 실패시 모든 연산이 실패합니다.
    - Consistency(일관성): 트랜잭션은 유효한 상태로만 변경될 수 있습니다.
    - Isolation(고립성): 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.
    - Durability(내구성): 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)
    - 꼬리 질문
        - ACID 원칙 중 Durability를 DBMS는 어떻게 보장하나요?
            - DBMS는 다양한 방법을 제공하며 보통 로그 파일에 기록한 후 트랜잭션에 커밋하는 과정을 거칩니다.
        - 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
            - 여러 개의 SQL 작업을 하나의 단위로 묶어서 실행할 때 사용합니다.
            - 제가 중요하게 생각한 것은 연관된 작업끼리만 묶는 것이였습니다.
        - 읽기에는 트랜잭션을 걸지 않아도 될까요?
            - 단순 조회 작업이 많고, 데이터 정합성이 중요하지 않을 때는 트랜잭션을 걸 필요가 없다고 생각하지만 같은 트랜잭션 내에서 여러 번 조회를 해야하며 **REPEATABLE READ 격리 수준**을 유지해야 하는 경우 락을 걸어야 합니다. MySQL을 주로 사용해왔기에 읽기 중에 트랜잭션을 걸었습니다.
- **트랜잭션 격리 수준에 대해 설명해주세요**
    
    트랜잭션의 격리 수준(Isolation Level)은 **동시에 여러 트랜잭션이 수행될 때 데이터의 일관성을 유지하면서도 성능을 조절하는 방식**입니다. 높은 격리 수준일수록 데이터의 일관성(고립도)은 증가하지만, 그만큼 성능 저하(락 발생 등)가 발생할 수 있습니다.
    
    ### **트랜잭션 격리 수준 4가지**
    
    1. **READ UNCOMMITTED (읽기 허용, 커밋되지 않은 데이터 포함)**
        - **설명**: 다른 트랜잭션에서 아직 커밋되지 않은 데이터를 읽을 수 있습니다.
        - **문제점**:
            - **더티 리드(Dirty Read)**: 한 트랜잭션에서 수정 중인(커밋되지 않은) 데이터를 다른 트랜잭션이 읽을 수 있음 → 이후 롤백되면 일관성 문제 발생
    2. **READ COMMITTED (커밋된 데이터만 읽기 가능)** *(많이 사용됨)*
        - **설명**: 다른 트랜잭션에서 **커밋된 데이터만 읽을 수 있음** (커밋되지 않은 데이터는 읽을 수 없음).
        - **문제점**:
            - **Non-repeatable Read (비반복 읽기)**: 같은 트랜잭션 내에서 같은 데이터를 두 번 조회하면, 중간에 다른 트랜잭션이 데이터를 변경하여 다른 결과가 나올 수 있음.
    3. **REPEATABLE READ (반복 읽기 보장, 하지만 팬텀 리드 문제 존재)** *(MySQL 기본값)*
        - **설명**: 같은 트랜잭션 내에서는 동일한 `SELECT` 쿼리를 실행하면 항상 같은 결과가 조회됨(다른 트랜잭션에서 데이터를 수정하거나 삭제해도 반영되지 않음).
        - **문제점**:
            - **팬텀 리드(Phantom Read)**: 한 트랜잭션에서 범위 조회(`SELECT WHERE`) 시, 다른 트랜잭션이 새로운 행을 추가하면 처음 조회 시점과 결과가 달라질 수 있음.
        - **보완책**: MySQL의 **InnoDB는 갭 락(Gap Lock)을 사용**하여 **팬텀 리드를 방지**함.
    4. **SERIALIZABLE (가장 강력한 격리 수준, 성능 저하 큼)**
        - **설명**: 모든 트랜잭션을 직렬화하여 실행함 → 동시에 실행되지 않고 순차적으로 실행됨.
        - **특징**: **락을 걸어서 트랜잭션 간 충돌 방지** (ex: SELECT도 락이 걸려 동시 접근 불가)
        - **문제점**: 성능이 크게 저하됨 (트랜잭션 간 대기 시간이 길어짐).
    - 꼬리 질문
        - MVCC에 대해 설명해주세요
            - MVCC는 멀티 버전 컨시스턴스 컨트롤로 MySQL에서 락 없는 조회를 지원합니다. 이로인해서 동시성을 향상시킵니다.
            - 기본적인 원리는 데이터 수정 시에 스냅샷(언두 로그)를 저장하여 조회 요청 시에 언두 로그를 읽는 형식으로 동작합니다.
        - MySQL은 갭락을 이용해서 어떻게 팬텀 리드를 방지하나요?
            - 갭락은 범위 조회에서 수정이 불가능하게 범위 락을 거는 것을 말합니다. 이것을 이용해서 조회 시에 트랜잭션이 해당 범위에 접근하는 것을 막습니다.
        - 모든 DBMS가 4개의 격리 수준을 사용하나요?
            - 아니요 모든 DBMS가 4가지 격리 수준을 구현하지 않습니다.
            - 그 이유는 각 DBMS마다 성능, 동시성, 무결성 보장 방식이 다르기때문입니다.
        - MySQL에서 Undo와 Redo
            - 언두 로그란 롤백 또는 mvcc를 위한 데이터 스냅샷 공간입니다.
            - 리두 로그는 데이터 변경 사항을 저장하여 장애 발생 시 복구하는 영역입니다.
        - 스토리지 엔진이란?
            - DBMS에서 데이터를 저장하고 관리하는 방식을 구현한 모듈입니다. MySQL에서 여러 스토리지 엔진을 지원하며 MyISAM과 InnoDB가 있습니다.
- **정규화에 대해 설명해주세요**
    
    정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미합니다. 
    
    - 데이터를 여러 개의 작은 테이블로 분리하여 중복을 제거하고, 삽입/수정/삭제 이상을 방지하는 것이 목적입니다.
    - 정규화 단계
        - 제 1정규형 : 모든 속성이 원자값을 가져야한다.
        - 제 2정규형 : 부분 함수 종속을 제거해야한다.
        - 제 3정규형 : 이행적 함수 종속을 제거해야 한다.
    
    정규화는 말 그대로 데이터 무결성 유지와 중복 최소화를 위한 것이지만 성능 저하가 발생할 수 있습니다. 그렇기에 융통성 있는 설계를 위한 비정규화가 필요합니다.
    
- **DB의 Connection Pool에 대해 설명해 주세요.**
    
    커넥션 풀(Connection Pool)은 **DB 연결을 미리 생성하여 관리하고, 필요한 요청이 있을 때 재사용하는 기법**입니다.
    
    매번 새로운 DB 연결을 생성하면 **TCP/IP 연결, 인증, 세션 설정 등의 오버헤드**가 발생하는데, **커넥션 풀을 사용하면 이러한 리소스를 절약**할 수 있습니다.
    
    Spring Boot에서는 기본적으로 **HikariCP**를 사용하며, **Tomcat JDBC Pool, C3P0** 같은 다른 옵션도 존재합니다.
    
- **DB 조인에 대해 설명해주세요**
    
    **JOIN**은 **두 개 이상의 테이블을 연결하여 데이터를 조회하는 SQL 연산**입니다.
    
    각 테이블 간 **공통된 컬럼(키, FK 등)을 기준으로 데이터를 결합**할 수 있습니다.
    
    ### ✅ **JOIN의 종류**
    
    | JOIN 종류 | 설명 | 예제 |
    | --- | --- | --- |
    | **INNER JOIN** | 두 테이블에서 **조건이 일치하는 데이터만 반환** | `SELECT * FROM A INNER JOIN B ON A.id = B.id;` |
    | **LEFT JOIN** | **왼쪽 테이블의 모든 행 + 일치하는 오른쪽 테이블 데이터** | `SELECT * FROM A LEFT JOIN B ON A.id = B.id;` |
    | **RIGHT JOIN** | **오른쪽 테이블의 모든 행 + 일치하는 왼쪽 테이블 데이터** | `SELECT * FROM A RIGHT JOIN B ON A.id = B.id;` |
    | **FULL OUTER JOIN** | **두 테이블에서 일치하는 모든 데이터를 반환 (MySQL 미지원, UNION 사용)** | `SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id;` |
    | **CROSS JOIN** | **두 테이블의 모든 데이터 조합(카티전 곱)** | `SELECT * FROM A CROSS JOIN B;` |
    - 꼬리 질문
        - JOIN의 내부 구현 방식은 뭔가요?
            - JOIN의 실행은 실행 계획에 따라 달라집니다.
            - 중첩 루프 조인은 한쪽 테이블을 루프 돌면서, 다른 테이블에서 일치하는 값을 찾습니다.
            - 해쉬 조인은 한 테이블의 데이터를 해시 테이블로 변환 후, 다른 테이블의 데이터를 비교합니다.
            - 소트 머지 조인(Sort Merge Join)은 조인할 두 테이블을 정렬 후 병합하여 결과를 반환합니다.
        - JOIN 성능과 인덱스의 관계가 있을까요?
            - 조인의 성능은 인덱스 유무에 따라 크게 달라집니다.
            - 조인 키에 인덱스가 없으면 풀 테이블 스캔이 발생하며 있으면 빠르게 탐색이 가능합니다.
        - 3중 조인과 성능
            - 두 개 이상의 테이블을 조인할 경우 방식과 순서에 따라 최적화에 영향을 미칩니다. 가장 작은 테이블을 기준으로 하는 것이 좋습니다.
- **View란 무엇이고, 언제 사용하나요?**
    
    뷰란 실제 테이블을 기반으로 생성된 가상 테이블입니다.
    
    기존 테이블을 조회하는 sql 쿼리를 저장하여 마치 하나의 테이블로 운용합니다. 
    
    논리적 독립성이 필요하거나 복잡한 쿼리를 단순하게 관리할 수 있습니다. 
    
- **B-Tree와 B+Tree에 대해 설명해 주세요.**
    
    **🔹 B-Tree**
    
    - **균형 탐색 트리(Balanced Search Tree)의 한 종류**로, DB 인덱스에서 많이 사용됨
    - 각 노드에 **데이터(Key)와 포인터(Child Pointers)가 함께 저장됨**
    - **데이터를 루트에서 리프까지 저장**하여, 검색, 삽입, 삭제 성능이 일정하게 유지됨
    - **모든 키가 내부 노드와 리프 노드에 분포**
    - **레코드를 찾으면 즉시 반환 가능**
    
    **🔹 B+Tree**
    
    - **B-Tree를 확장한 구조**
    - **모든 데이터는 리프 노드에만 저장**, 내부 노드는 인덱스 역할만 수행
    - 리프 노드끼리는 **Linked List로 연결**되어 있어 **범위 검색이 빠름**
    - **높이가 낮아지므로 디스크 I/O 감소 → 성능 최적화**
    - 꼬리 질문
        - **B+Tree가 B-Tree보다 무조건 좋은가?**
            - B+Tree는 범위 조회에 빠르고 디스크 접근 성능이 좋아지지만 삽입 삭제 시 오버헤드가 증가합니다. 또한 개별 데이터 조회에서는 B-Tree가 빠를 수도 있습니다.
        - 오름차순 인덱스에서 내림차순 정렬을 수행하면 성능이 어떻게 될까?
            - 인덱스를 내림차순 정렬을 수행하면 역순 탐색을 실행합니다. B-Tree는 역순 탐색에 최적화 되어 있지 않아 성능 저하가 가능하며 B+Tree는 역순 탐색도 빠르게 처리 가능합니다.
- **트래픽이 높아질 때, DB는 어떻게 관리할 수 있을까요?**
    
    **1️⃣ 수직 확장(Scale-Up)**
    
    - **더 강력한 하드웨어로 교체** (CPU, RAM, SSD 업그레이드)
    - **DB 튜닝**을 통해 성능 최적화 (인덱스 최적화, 캐싱, 실행 계획 분석)
    - 단점: **하드웨어 비용 증가, 한계점 존재**
    
    **2️⃣ 수평 확장(Scale-Out)**
    
    - **Replication(복제) 적용** → 읽기 부하 분산
    - **Sharding(샤딩) 적용** → 데이터를 여러 DB에 분산 저장
    - 단점: **운영 복잡성 증가**
    
    **3️⃣ 캐싱 적용 (Redis, Memcached)**
    
    - **자주 조회되는 데이터는 DB 대신 캐시에서 조회**
    - API 요청을 캐싱하면 **DB 부하 감소 및 응답 속도 향**
    - 단점: **데이터 동기화 문제 발생 가능**
    - 꼬리 질문
        - DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은?
            - **인덱스 최적화 : 불필요한 Full Table Scan을 방지**
            - 쿼리 최적화 & 배치 처리
            - 캐싱 활용
- **Table Full Scan & Index Range Scan 개념**
    
    ✔ **Table Full Scan (테이블 풀 스캔)**
    
    - **모든 데이터를 조회하는 방식**
    - **디스크 I/O 비용이 큼** (순차 I/O 사용)
    - **WHERE 조건이 없거나, 인덱스를 사용하지 않는 경우 발생**
    
    ✔ **Index Range Scan (인덱스 범위 스캔)**
    
    - **인덱스를 이용해 특정 범위의 데이터만 조회**
    - **랜덤 I/O 방식 사용 (필요한 부분만 접근)**
    - **WHERE 절의 범위 조건 (>, <, BETWEEN, LIKE ‘abc%’)을 사용할 때 최적화됨**
    - 꼬리 질문
        - 가끔 인덱스가 있음에도 Table Full Scan을 하는 이유가 뭘까요?
            - 조회하는 데이터가 전체 테이블의 과반수 이상인 경우 테이블 풀 스캔을 진행합니다 대량 데이터 조회 시 풀 테이블 스캔의 순차 IO가 인덱스의 랜덤 IO보다 빠르기에 그렇습니다.
- **SQL Injection이란?**
    
    SQL Injection(이하 SQLi)은 **사용자로부터 입력받은 데이터가 SQL 쿼리에 직접 포함되면서 발생하는 보안 취약점**입니다.
    보통의 서비스 들은 파라미터 바인딩을 활용하여 막습니다. 
    
- **Schema란 무엇인가요?**
    
    "Schema는 데이터베이스의 구조와 제약 조건을 정의하는 설계도입니다. DBMS는 데이터 저장 및 관리를 효율적으로 하기 위해 3계층 구조를 가지는데, 외부 스키마는 사용자가 보는 데이터 뷰, 개념 스키마는 DB의 전체 논리적 구조, 내부 스키마는 데이터가 실제 저장되는 방식을 정의합니다. 이러한 구조를 통해 데이터 독립성을 유지하고, 효율적인 데이터 관리를 가능하게 합니다.”
    
- **MongoDB와 Redis에 대해 설명해주세요**
    
    "MongoDB는 대표적인 NoSQL 데이터베이스로, 문서(Document) 기반의 저장 방식을 사용합니다. JSON 형태의 데이터를 저장하며, 스키마가 유연하여 구조 변경이 용이하고 대량의 데이터를 빠르게 처리할 수 있습니다. 반면, Redis는 In-Memory 데이터베이스로, 데이터를 메모리에 저장하여 매우 빠른 읽기/쓰기 성능을 제공합니다. 주로 캐싱, 세션 관리, 실시간 데이터 처리가 필요한 경우에 사용됩니다. MongoDB는 복잡한 데이터 저장 및 조회에 적합하고, Redis는 빠른 응답이 필요한 상황에서 강점을 가집니다.”
    
- **SQL과 NOSQL의 차이에 대해 설명해주세요**
    
    "SQL은 관계형 데이터베이스(RDBMS)에서 사용하는 언어로, 정해진 스키마(테이블 구조)를 기반으로 데이터를 저장하며, ACID 특성을 보장합니다. 대표적인 SQL DB에는 MySQL, PostgreSQL, Oracle 등이 있습니다. 반면, NoSQL은 비정형 데이터를 저장하는 방식으로, 문서(Document), 키-값(Key-Value), 컬럼(Column-Family), 그래프(Graph) 등 다양한 데이터 모델을 지원합니다. 스키마가 유연하여 구조 변경이 쉽고, 수평적 확장이 용이하다는 장점이 있습니다. 대표적인 NoSQL DB에는 MongoDB, Redis, Cassandra 등이 있습니다.”
    
- **로그와 버퍼가 오류 발생 시에 대해 설명해세요.**
    1. 리두 로그
        1. 역할 : 트랜잭션이 변경한 내용을 디스크에 쓰기 전에 변경 사항을 기록한다.
        2. 오류 대책
            1. 시스템 크래시 시 → 디스켕 반영되지 않은 사항을 로그로 재적용시켜 복구
            2. 커밋된 로그는 디스크에 반드시 기록
    2. 언두 로그
        1. 역할 : 트랜잭션 수행 중 변경 전 상태를 저장하는 스냅샷 주로 롤백이나 MVCC에 사용
        2. 오류 대책
            1. 트랜잭션 도중 오류나 커밋 전 오류를 롤백 요청
    3. 더블 라이트 버퍼
        1. 역할 : 디스크에 데이터를 쓸 때, 먼저 별도의 버퍼 영역에 두 번 저장하는 메커니즘
        2. 오류 대책
            1. 시스템이 디스크에 페이지를 스다가 중간에 크래시가 나면 해당 페이지가 깨짐
            2. 그래서 먼저 더블 라이트 버퍼에 안전하게 저장 후 다시 실제 데이터 파일에 쓴다
